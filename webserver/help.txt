strpbrk函数
【1】函数功能：strpbrk是在源字符串（s1）中找出最先含有搜索字符串（s2）
中任一字符的位置并返回，若找不到则返回空指针。
#include <string.h>


strcasecmp函数
【1】函数功能 ：比较参数s1和s2字符串，比较时会自动忽略大小写的差异。

【2】返回值： 若参数s1和s2字符串相等则返回0。s1大于s2则返回大于0 的值，s1 小于s2 则返回小于0的值。

【3】头文件#include <strings.h>


extern char *strchr(const char *s,char c);说明：返回首次出现c的位置的指针，如果s中不存在c则返回NULL。


- 为了提高资源文件访问速度，通过内存映射，将普通文件映射到内存，内存映射区对应的内存空间在进程的用户区。
- 拓展：进程间通信使用的内存映射区在每个进程内部都有一块。由于每个进程的地址空间是独立的，各个进程不能
直接访问对方的内存映射区。
- 解决方法：需要通信的进程需要将各自的内存映射区和同一个磁盘文件进行映射。

2. 不论注册方式是 EPOLLIN | EPOLLOUT | EPOLLET 还是 EPOLLOUT | EPOLLET 只要含EPOLLOUT
对于EPOLLOUT: 如果状态改变了[比如 从满到不满],只要输出缓冲区可写就会触发;
只要状态改变就能触发.

     状态改变到底是什么?   简单理解:

     EPOLLOUT:  满->不满 

     EPOLLIN   :  空->不空

     有没有发现 , 都跟边缘有关

3.对于 send / write 需要依靠 EPOLLOUT 触发才调用吗 ? 什么时候需要 注册上 EPOLLOUT ?

   不需要.  如果要 send / write 那么就直接调用, 如果返回值 > 0  , 证明数据已经复制到发送缓冲区中.一切正常.

    如果 send / write 返回 < 0 且 errno == EAGAIN . 此时说明发送缓冲区满了. 那么需要把 剩余的字节保存起来,

    然后注册上 EPOLLOUT , 直到epoll_wait 返回 , 说明发送缓冲区可写, 再把 之前保存起来的数据 发送,

    如果此时 write 返回 > 0  那就把EPOLLOUT 取消掉. 

    简单来说 :  1. 直接发送  2. 看返回值, 没发送完才挂上EPOLLOUT  3. 发送完就把EPOLLOUT 取消掉

writev允许处理非连续的数据块。也就是说，缓冲区可以逐个单独分配，不用是一块连续的较大的地址空间。
writev 的I/O是“原子的”。例如，如果你执行一个writev操作，所有数据将在一个连续操作中被写入，不会被中断。
如果使用write，则必须在以下两种情况下进行选择:使用memcpy(带来额外开销)将它们复制到一个内存块中，然后再
执行一个write调用。
进行三个独立的write调用(带来额外开销)。另外，来自其他进程的write调用可以分散在这些write之间
(也就是整体上看不是原子操作)。